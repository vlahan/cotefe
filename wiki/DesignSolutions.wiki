Clarifying the concepts of Task as REST resource and Task in Google App Engine Task Queue API.

Although the Task resource has been openly inspired by the GAE Task class they are distinct aspects of the CTF Platform, aiming to solve different problems.
The Task resource is defined in the context of REST. It is a way to represent an operation to by executed within a given Job. We need Tasks if we want to leverage the automatic execution of experiments provided by the CTF.
The GAE Task is a feature provided by GAE that allows execution of asynchronous operations. It provides a way to append a give task to a queue, with the promise to be completed as soon as possible (when the resources will be available, according to the GAE internal policies).
http://code.google.com/appengine/docs/python/taskqueue/overview.html
http://code.google.com/appengine/docs/python/config/queue.html
Execution mode	Task resource	Interaction mode	GAE Task Queue	Description	Examples
Live/Manual mode	No	sync	No	In this case the user is submitting an HTTP request without encapsulating it in a Task and there is no need to run the operation as an asynchronous GAE Task.	Start/stop tracing, inject a message to a node
Live/Manual mode	No	async	Yes	I this case the user is still working in Live mode but his HTTP requested is appended to the default Task Queue and executed aynchronously when the resources allow.	Install an image on 100 nodes
Batch/Auto mode	Yes	sync	No	In this case, the user must  create a Task resource for each operation he wants to run. It is the only way to store information about Batch execution mode. The entity of the operation is such that GAE does not need to encapsulate this operation in an asynchronous GAE Task.	Start/stop tracing, inject a message to a node
Batch/Auto mode	Yes	async	Yes	In this case, the user is still required to create Task resources for every operation he wants to run and the entity of the operation is such that it requires asynchronous execution with GAE Tasks.	Install an image on 100 nodes

How can we trigger the execution of batch mode experiments?

We can use the Cron feature provided by GAE. We might create a Cron script for example  that every half an hour (or every 10 minutes, according to the minimum reservation time interval allowed) looks for new Jobs about to start (within a certain time interval).
http://code.google.com/appengine/docs/python/config/cron.html
Job status attribute legend

The definition of the different status that a job can have is necessary both in the description of the user experience and for a better understanding of the meaning of the status field in the Job resource representation.
Time	Status	Definition
now() < datetime_from	available	When a Job is created (new resource with URI) its status is available. Then the user is required to commit its reservation within a given time interval. During this interval other users are not allowed to reserve any overlapping jobs. If the user commits its status turns into reserved, otherwise the resource is deleted.
now() < datetime_from	reserved	Once the user has committed reservation the Job status is reserved. It stays reserved until the instant when the job execution start is scheduled to happen.
datetime_from < now() < datetime_to	ready	The reserved job is ready to be executed (Live mode).
datetime_from < now() < datetime_to	running	The job is running.
datetime_to < now()	completed	Indicates that the job has been executed successfully (with no errors).
datetime_to < now()	failed	Indicates that the job has been executed with errors from the client side (i.e. bad format of information submitted..)
datetime_to < now()	error	Indicates that the job has been executed with errors from the server side (i.e. resources didn’t behave as expected, system failure..)
-

rescheduled by admin


How to guarantee serial execution of Tasks?

In some cases we may want that a task starts ONLY when one or more previous tasks has been successfully completed. GAE does not provide any mechanism to solve this problem: once the task has been added to the queue there is no way to force serial execution.
A possible solution could be to introduce a further attribute for the Task resource called i.e. run_only_when_completed containing in identifier (URI) of a desired other Task. Example:

{
	“uri”: “https://www.example.org/tasks/2”
	“media”: “application/json”
	“name”: “start tracing”
	. . .
	“run_only_when_completed”:
	{
		“uri”: “https://www.example.org/tasks/1”
		“media”: “application/json”
		“name”: “install image on all nodes”
	}
}
How do we achieve asynchronous execution at different “layers” of the architecture?

User	-	-
Web Client	HTML + Javascript	XMLHttpRequest
Federation Server	GAE	Tast Queue API
Testbed Server	Django	Celery
Native Server (when supported)	Twisted	Twisted Deferreds

Design

The CONET Testbed Federation is a distributed 3-layered system and its design entails the the definition of 2 APIs.

Federating testbeds with different capabilities and resources entails a series of trade-offs.

Each member testbed was build and evolved independently form the others and presents different capabilities, interfaces, communication protocols, languages, data formats and so on. The design of the testbed federation requires

reuse of resources
Services

The aim of the CTF is to enable experimentally-driven WSN research by providing a complete set of services definition, execution and easy migration of WSN experiments across a number of autonomous testbed members.

The research who approaches the CTF can make use of a set of tools supporting all different aspects of the experimental research process, such as:
experiment specification
resource discovery
resource reservation
experiment execution
collection/storage of results

furthermore enabling additional services, such as:
authentication, authorization, accounting
a language for the abstract specification of experiments
easy migration of experiments across member testbeds
sharing of experimental results among users and communities of users 

Coexistance

One goal of the CTF is to provide a high degree of autonomy to the member testbeds. Being part of a federation should not prevent member testbed from autonomously managing user access policies and simultaneous use of TFA, TAAs and TNAs.
The Client-Server-Server Architecture

xxx
The Asynchronous Pattern

xxx