=Overview=

The purpose of this document is to support both the implementation and use of the Testbed Abstraction API (TAA), an interface that aims to expose the capabilities of a cooperating object testbed as a service. The TAA was conceived in the context of the European Network of Excellence project CONET as part of the CONET Testbed Federation (CTF), where it represents a uniform interface across all member testbeds. It allows the developers for building applications (standalone, client-side web applications, server-side web applications, mash-ups) accessing the services offered by a given testbed. A prototype of the TAA has been implemented on top of TWIST, the TU Berlin Wireless Indoor Sensor Network, as a prove of concept of research for review and evaluation within the same project.

The TAA has been designed according to the REST architectural style. REST introduces design constraints with the promise to fully leverage the potential of the Web and its worldwide distributed infrastructure, in order to achieve scalability, reliability, extensibility of the service and interoperability with other Web Services.

After an introductory description of the core design aspects we provide a detailed specification of resources involved and we will show how to perform typical testbed operations in terms of manipulation of such resources, according to the REST architectural style.
Then, we provide a series of guidelines for the integration of the TAA with the legacy native interface provided by a given existing testbed for cooperating objects. We will show to install and extend the TAA software that we developed in order to adapt to any specific testbed. Finally, a detailed tutorial will show how to execute a sample experiment using the TAA.

=System Architecture=

The architecture of the TAA is shown in the picture here below. According to the  the testbed-independent and the testbed-specific parts] The implementation of the TAA can be divided in front-end and back-end. The front-end is the testbed independent part and thus can be reused across different testbeds. We provide a prototype of the TAA front-end implemented in Django. The back-end is the testbed specific part and must be provided by the testbed administrator. The bridge between the front-end and back-end is in charge for translating common HTTP requests into specific testbed commands, according to the specific testbed native API.

The Testbed Abstraction API aims to expose a Cooperating Object testbed as a service. In the context of the Testbed Federation, it represents a uniform interface across all member testbeds. It is built according to the REST architectural style. REST introduces design constraints with the promise to achieve scalability, extensibility and reliability.

The implementation of the TAA can be divided in front-end and back-end. The front-end is the testbed independent part and thus can be reused across different testbeds. We provide a prototype of the TAA front-end implemented in Django. The back-end is the testbed specific part and must be provided by the testbed administrator. The bridge between the front-end and back-end is in charge for translating common HTTP requests into specific testbed commands, according to the specific testbed native API.

=Services=

During the design phase of the TAA we leveraged the mature usage experience of our testbed (TWIST) in order to identify the need and the key steps of a typical experiment with cooperating objects. Testbeds play and important role in the design, development and test of protocols and applications as they provide controlled execution of experiments in a realistic environment, where functional and non-functional behaviors can be tracked and stored for further analysis and evaluation.

As every system allowing authenticated users access to limited and distributed resources, the CTF requires discovery, reservation and scheduling capabilities, to provide the users with a view of the federation, to avoid conflicts, optimize usage and improve the user’s experience.
Discovery, reservation and scheduling must be highly available as if they becomes unavail- able the entire access to resources is compromised.
Scalability is also a strong requirement: the federation will include several testbeds, the number of users and nodes may increase considerably to potentially hundreds users and thousands of nodes and a continuous monitoring of the target infrastructure may lead to a significant load.
As we show in the next sections, Resource Discovery, Reservation and Scheduling take and inherit full advantage of the benefits of a HTTP RESTful architecture, such as identifying resources with URIs and caching. In the last section we present two notable cases of related work, emphasizing the main differences with our approach.

==Resource Discovery==

In a federation of testbeds, where both physical and virtual resources are distributed across a worldwide heterogeneous network, an integrated mechanism for resource discovery is necessary to provide users with an overview of the state of the underlying resources.
With the general term of resources we here indicate every single entity in the federation that can be addressed and accessed by applications. This does not include only nodes, which are the final objective of the whole CTF, but also any other entity that may take part to the experiment for any purpose, such as measuring, monitoring or simply forwarding information
(i.e. channel scanners, spectrum analyzers).
While every experiment requires a specific subset of resources, we don’t want to force
the user to browse for them on every testbed. On the contrary we need to provide the user with an abstract aggregated view of the current state of the federation through a minimum number of effort and a priori assumptions.
Moreover, resource discovery must allow tracking of both relatively static and frequently changing resource characteristics and loosening and tightening of the granularity of the search- ing filter, according to the user’s needs, by means of an expressive and adaptive query lan- guage.
Discovery happens at two different levels: federation level and testbed level. At federation level discovery is in charge to gather information coming from the different testbeds, while at testbed level the information is retrieved from the testbed resources. Such a hierarchical structure allows the discovery query processing to be distributed among all testbeds avoiding significant load at the federation level.
A discovery query issued to the CTFS may be split in resource discovery and availability discovery. The resource discovery answers to the question What is present? while availability discovery answers to What is available?. Since the result of resource discovery is likely slowly changing over time, it can be cached in the CTFS, behaving here like a shared cache (proxy). During availability discovery the system retrieves a collection of which resources are currently available in a specified time slot for a specified user. No detail about resources is returned in this phase, but only whether each resource is available for use or not. This is context- sensitive as it might be subject to access and priority policies. Decoupling information about resources and their availability allows discovery to inherit full advantage of REST, allowing optimization of caching.
This discovery request contains information about the searching parameters that could appear as HTTP GET query parameters or be uploaded (HTTP POST) as a document de- scribing the experiment to be performed including the needed resources.
An example list of parameters follows here:

    * platform type
    * radio technology
    * amount of nodes per node type
    * duration of experiment
    * mobile node required
    * sensors
    * actuators

==Resource Reservation==

In order to avoid collision and to allow concurrent access at same time, the CTF includes a global resource reservation system.
With collision, we mean the conflict generated by concurrent access to the a shared portion of space, frequency and time. In our case, if we assume that the different testbeds are far apart enough to grant no electromagnetic interference during concurrent experiments, we can conclude that collision is avoided as long as experiments run on different time slots and on different portion of the spectrum. A first simple approach would consist in reserving an entire testbed for a given slot of time. This would be enough to avoid any kind of conflicts during concurrent access to the federation by different users, but will not contribute to optimal usage of the resources.
In line with the federation philosophy, none of the resource reservation features should impose significant limits in autonomy and functionality of the individual testbeds. We assume that every testbed in the federation is already capable of managing reservations through the TA API. Where the native API does not allow concurrent access, we introduce a locking system at the federation level which temporarily isolates the testbed from the federation during access by native users.

==Resource Scheduling==

The CTFS introduces another layer of optimization which strongly impacts the user expe- rience. A complete knowledge of the status of the underlying resources allows the CTF to support additional functions like solving dependent reservation requests featuring inter- testbed parameters and optimizing the usage of resources by providing the user with a series of alternatives (both in resources and in time) whenever the request for reservation could not succeed.
In the ProtoGENI implementation and deployment of Global Environment for Network Innovations (GENI), a virtual laboratory for at-scale networking experimentation, RSpec de- fines concepts like advertisements, requests and tickets which constitute an ad-hoc solution to the problem of discovery and reservation. While Advertisements describe resources provided by component managers, requests describe the resources that a client wants and tickets are resource reservations which are promised by a component manager to a client or broker. In our case advertisements are simply responses to aggregated requests about the state of the federation (mostly related with slowly varying information), requests are simply discov- ery queries and tickets are simply URLs pointing at the resource created out of a successful request for a new reservation.

==Experiment Specification and Control==

The main goals of the CTF is to facilitate running a given experiment on different testbeds. To do this conveniently the CTF must provide facilities for specifying the experiment setup in a testbed independent manner, as well as a facility for issuing the control commands necessary for preparing the experiments environment, executing the experiment and collecting results.

===Interactive Mode===

===Batch Mode===

==Experiment Results and Debug Data==

=Documentation=

==Introduction==

All testbed resources are accessed and manipulated in a similar way. Resources are identified by URLs and accessed by a common interface (HTTP methods). A list of resources is usually available through `/[resource name]`, while a single specific resource through `/[resource name]/[resource id]` and related subresources (i.e. a user's jobs) through `/[resource name]/[resource id]/[subresource name]`. It exposes testbed resources as REST resources, which can be accessed and manipulated through a uniform interface.

|| `HTTP GET [resource URL]` || Gets a representation of a given resource indicated by the URL ||
|| `HTTP POST [resource URL]` || Create a new resource according to the representation provided in the request ||
|| `HTTP PUT [resource URL]` || Updates the resource at the given URL by providing a new representation ||
|| `HTTP DELETE [resource URL]` || Updates the resource at the given URL by providing a new representation ||

Since all member testbeds have been built and evolved autonomously and independently and differ in infrastructure, capabilities and services they provide. After a survey and analysis of the federation membership, a set of features has been selected and we believe it being a common ground of requirements in order for a testbed to be part of the federation. The selected representation format for resources and collections of resources is JSON.

The following example uses cURL to simply access the TA API

{{{$ curl https://api.cotefe.net/jobs/}}}

==Authentication==

By mean of a simple tool like cURL it is possible to access public resources in read-only mode (only HTTP GET is allowed). Public resources include, testbed resources in terms of available infrastructure, public jobs and statistics. Any access to private information related to a given user requires authentication and authorization - the user needs to delegate access to their private resources and this is achieves by means of the OAuth 2.0 protocol.
OAuth is an authorization protocol that aims to solve the problem of granting third-party  application access to private resources by issuing credentials which can be revoked at any time and limited to a desired resource and/or time domain.

|| Authorization Endpoint (authorization code) || `https://www.example.org/oauth2/auth` ||
|| Token Endpoint (access token) || `https://www.example.org/oauth2/token` ||
|| Redirection URI || `https://www.example.org/oauth2/callback` ||

Example:

{{{$ curl https://api.example.org/oauth2/auth?response_type=code&redirect_uri=https://api-cotefe.net.appspot.com/oauth-callback}}}

==Resources==

Following the REST constrain known as Hypermedia As The Engine Of Application State (HATEOAS) the entire resource tree structure can be explored starting from / (which represents the testbed resource) and then following the link attributes provided by each resource representation. Each interaction (HTTP request) with the TA API is stateless, there is no awareness about clients on the server and only the client is responsible of keeping the application state.

<wiki:comment>

===User===

The user resource represents the user as main actor of the TAA. It contains all the information realted to the user of the system such as name, organization, contact information and a unique identifier (OpenID identifier).

|| `URI` || A GET against this URI refreshes the representation of this resource` ||
|| `name` || An arbitrary given name for this resource ||
|| `media-type` || `application/json` ||

===Federation===

|| `URI` || A GET against this URI refreshes the representation of this resource` ||
|| `name` || An arbitrary given name for this resource ||
|| `media-type` || `application/json` ||

===Experiment===

The Experiment resource enables testbed-independent experiment description in terms of required resources (expressed in Property Sets) and list of operations (expressed in Virtual Tasks) to be executed in order to complete a given experiment. The Experiment resource can be created, deleted and modified, and easily shared with other users of the federation.

|| `URI` || A GET against this URI refreshes the representation of this resource` ||
|| `name` || An arbitrary given name for this resource ||
|| `media-type` || `application/json` ||

===PropertySet===

|| `URI` || A GET against this URI refreshes the representation of this resource` ||
|| `name` || An arbitrary given name for this resource ||
|| `media-type` || `application/json` ||

===VirtualNode===

|| `URI` || A GET against this URI refreshes the representation of this resource` ||
|| `name` || An arbitrary given name for this resource ||
|| `media-type` || `application/json` ||

===VirtualNodeGroup===

|| `URI` || A GET against this URI refreshes the representation of this resource` ||
|| `name` || An arbitrary given name for this resource ||
|| `media-type` || `application/json` ||

===Image===

|| `URI` || A GET against this URI refreshes the representation of this resource` ||
|| `name` || An arbitrary given name for this resource ||
|| `media-type` || `application/json` ||

===VirtualTask===

|| `URI` || A GET against this URI refreshes the representation of this resource` ||
|| `name` || An arbitrary given name for this resource ||
|| `media-type` || `application/json` ||

===Testbed===

The Testbed represents the whole testbed infrastructure made of hardware, software resources, scheduled jobs and users. It is the root resource, i.e. the starting point for self discovery/search of any sort of resource by navigation of iterated exploration of URL links, similarly to the web browser model.
The testbed resource represents the testbed itself and contains all informations about characteristics, assets and capabilities. It is the starting point for all REST resources to be explored and discovered.

|| `URI` || A GET against this URI refreshes the representation of this resource` ||
|| `name` || An arbitrary given name for this resource ||
|| `media-type` || `application/json` ||

===Node===

|| `URI` || A GET against this URI refreshes the representation of this resource` ||
|| `name` || An arbitrary given name for this resource ||
|| `media-type` || `application/json` ||

===NodeGroup===

|| `URI` || A GET against this URI refreshes the representation of this resource` ||
|| `name` || An arbitrary given name for this resource ||
|| `media-type` || `application/json` ||

===Socket===

|| `URI` || A GET against this URI refreshes the representation of this resource` ||
|| `name` || An arbitrary given name for this resource ||
|| `media-type` || `application/json` ||

===Job===

|| `URI` || A GET against this URI refreshes the representation of this resource` ||
|| `name` || An arbitrary given name for this resource ||
|| `media-type` || `application/json` ||

===Task===

|| `URI` || A GET against this URI refreshes the representation of this resource` ||
|| `name` || An arbitrary given name for this resource ||
|| `media-type` || `application/json` ||

===Trace===

|| `URI` || A GET against this URI refreshes the representation of this resource` ||
|| `name` || An arbitrary given name for this resource ||
|| `media-type` || `application/json` ||

===Log===

|| `URI` || A GET against this URI refreshes the representation of this resource` ||
|| `name` || An arbitrary given name for this resource ||
|| `media-type` || `application/json` ||

===Status===

The status resource is an auxiliary resource that we introduced to provide some information about the status of an asynchronous request

|| `URI` || A GET against this URI refreshes the representation of this resource` ||
|| `name` || An arbitrary given name for this resource ||
|| `media-type` || `application/json` ||

===Platform===

|| `URI` || A GET against this URI refreshes the representation of this resource` ||
|| `name` || An arbitrary given name for this resource ||
|| `media-type` || `application/json` ||

===Sensor===

|| `URI` || A GET against this URI refreshes the representation of this resource` ||
|| `name` || An arbitrary given name for this resource ||
|| `media-type` || `application/json` ||

===Actuator===

|| `URI` || A GET against this URI refreshes the representation of this resource` ||
|| `name` || An arbitrary given name for this resource ||
|| `media-type` || `application/json` ||

===Interface===

|| `URI` || A GET against this URI refreshes the representation of this resource` ||
|| `name` || An arbitrary given name for this resource ||
|| `media-type` || `application/json` ||

=Code=

</wiki:comment>

